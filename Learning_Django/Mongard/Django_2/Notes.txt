python3 -m venv name
source name/bin/activate
django-admin startproject name
pip install django
python manage.py startproject
python manage.py migrate
python manage.py createsuperuser
python manage.py startapp (exp:home)
setting.py : home.apps.HomeConfig
urls.py : 
from django.urls import path, include
urlpatterns = [
    path('', admin.site.urls),
    path('home/', include('home.urls'))
]
create urls.py:
from django.urls import path
urlpatterns = [
    path('', views.<...>, name='<...>')
]
------------------------------------
setting.py :
TEMPLATES = {

'DIRS': [BASE_DIR / 'templates'],
'APP_DIRS': True,

}
Now we have 2 kind of templates directories : 
1. inside each app a directory named templates and inside that a template named the app itself
2. one directory next to the app directories named templates

include and extend :

extend is for inheritance and include is using an html inside other html
for example we inheritance base.html inside all of the files with extend and use navbar.html inside base.html
with include command !

--------------------------------------
views.py:

from django.views import View
from django.shortcuts import render

class Name(View, request):
    def get(self):
        pass
    def post(View, request):
        pass

in the urls.py when you want to call Name Class you should as_view() !
path( '', Name.as_view(), name='Name')

--------------------------------------

forms.py:

from django import forms

class Name(forms.Form):
    pass

--------------------------------------
Widgets for Forms:

forms.CharField(required=False)
forms.CharField(widget=forms.PasswordInput(attrs={'class': 'form-control', placeholder='YourPassword}))
forms.EmailField(widget=forms.EmailInput(attrs={'class': 'form-control}))
forms.CharField(widget=forms.TextInput(attrs={'class': 'form-control'}))

--------------------------------------

NameSpace:

inside urls.py of project needs a namespace in all the includes 
and then use a variable named app_name = 'namespace we chose'

--------------------------------------

Messages:

{% if messages %}
{% for msg in messages %}
<p>{{msg}}</p>
{% endfor %}
{% endif %}

--------------------------------------
from django.core.exception import ValidationError

def clean_<...>(self):
    sth = self.cleaned_data[<...>]
    .
    .
    .
    return sth

def clean_username(self):
    username = self.cleaned_data['username']
    user = User.objects.filter(username=username).exists()
    if user:
        raise ValidationError('Duplicate username !')
    return username

---------------------------------------

we override the clean method of forms in django when we want to 
validate fields that depends on each other 

def clean(self):
    cleaned_data = super().clean()
    f1 = cleaned_data.get('f1')
    f2 = cleaned_data.get('f2')
    if f1 and f2 and f1 != f2:
        return ValidationError(" 2 Fields Should Match!")